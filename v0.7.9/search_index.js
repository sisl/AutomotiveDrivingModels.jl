var documenterSearchIndex = {"docs":
[{"location":"agent_definitions/#Agent-Definition-1","page":"Agent Definition","title":"Agent Definition","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent Definitions describe the static properties of a traffic participants such as the length and width of the vehicle. It also contains information on the type of agent (car, pedestrian, motorcycle...).","category":"page"},{"location":"agent_definitions/#Interface-1","page":"Agent Definition","title":"Interface","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"You can implement your own agent definition by creating a new type inheriting from the AbstractAgentDefinition type. The following three functions must be implemented for your custom type:","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AbstractAgentDefinition\n    length\n    width\n    class","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.AbstractAgentDefinition","page":"Agent Definition","title":"AutomotiveDrivingModels.AbstractAgentDefinition","text":"AbstractAgentDefinition\n\nAn Agent definition represents static parameters characterizing an agent,  such as its physical dimensions.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#Base.length","page":"Agent Definition","title":"Base.length","text":"length(def::AbstractAgentDefinition)\n\nreturn the length of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveDrivingModels.width","page":"Agent Definition","title":"AutomotiveDrivingModels.width","text":"width(def::AbstractAgentDefinition)\n\nreturn the width of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveDrivingModels.class","page":"Agent Definition","title":"AutomotiveDrivingModels.class","text":"class(def::AbstractAgentDefinition)\n\nreturn the class of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent classes such as car, truck, and pedestrian are defined by integer constant in a submodule AgentClass.","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AgentClass","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.AgentClass","page":"Agent Definition","title":"AutomotiveDrivingModels.AgentClass","text":"A module to represent the different class of agents:\n\nMotorcycle\nCar\nTruck\nPedestrian\n\n\n\n\n\n","category":"module"},{"location":"agent_definitions/#Available-Agent-Definitions-1","page":"Agent Definition","title":"Available Agent Definitions","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    VehicleDef\n    BicycleModel","category":"page"},{"location":"agent_definitions/#AutomotiveDrivingModels.VehicleDef","page":"Agent Definition","title":"AutomotiveDrivingModels.VehicleDef","text":"VehicleDef(;class::Float64, length::Float64, width::Float64)\n\nVehicle definition which contains a class and a bounding box.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#AutomotiveDrivingModels.BicycleModel","page":"Agent Definition","title":"AutomotiveDrivingModels.BicycleModel","text":"BicycleModel\nBicycleModel(def::VehicleDef; a::Float64 = 1.5, b::Float64 = 1.5)\n\nVehicle definition representing the bicycle model\n\nFields\n\ndef::VehicleDef\na::Float64 distance between cg and front axle [m]\nb::Float64 distance between cg and rear axle [m]\n\n\n\n\n\n","category":"type"},{"location":"simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"Simulations can be run using the simulate! function.  A simulation updates the initial scene forward in time. Each simulation step consists of the following operations:","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"call the observe! function for each vehicle to update their driver model given the current scene \nsample an action from the driver model by calling rand on the driver model.\nupdate the state of each vehicle using the sampled action and the propagate method.\nrepeat for the desired number of steps","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"There are two main ways to call the simulate! function:","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"simulate!(scene::Frame{E}, roadway::R, models::Dict{I,M}, nticks::Int64, timestep::Float64; rng::AbstractRNG = Random.GLOBAL_RNG, scenes::Vector{Frame{E}} = [Frame(E, length(scene)) for i=1:nticks+1], callbacks = nothing) which simply returns a vector of scenes. This vector can be pre-allocated and passed as a keyword argument. The randomness of the simulation can be controlled by passing a random number generator. \nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) which fills in a given QueueRecord object. The QueueRecord data structure is defined in Records.jl. This methods is slower and suffers from type stability issues. It will be deprecated in future releases.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"See the tutorials for examples.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    simulate!\n    get_actions!\n    tick!","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.simulate!","page":"Simulation","title":"AutomotiveDrivingModels.simulate!","text":"simulate!(scene::Frame{E}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int64, timestep::Float64; rng::AbstractRNG = Random.GLOBAL_RNG, scenes::Vector{Frame{E}} = [Frame(E, length(scene)) for i=1:nticks+1], callbacks=nothing)\n\nRun nticks steps of simulation with time step dt and return a vector of scenes from time step 0 to nticks.\n\nsimulate!(::Type{A}, rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int)\nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M<:DriverModel}, nticks::Int)\n\nRun nticks of simulation and place all nticks+1 scenes into the QueueRecord\n\nsimulate!(::Type{A},rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) where {S,D,I,A,R,M<:DriverModel,C<:Tuple{Vararg{Any}}}\nsimulate!(rec::EntityQueueRecord{S,D,I}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I,M}, nticks::Int, callbacks::C) where {S,D,I,A,R,M<:DriverModel,C<:Tuple{Vararg{Any}}}\n\nCallback objects can also be passed in the simulate! function.\n\n\n\n\n\nRun a simulation and store the resulting scenes in the provided QueueRecord.\n\nOnly the ego vehicle is simulated; the other vehicles are as they were in the provided trajdata Other vehicle states will be interpolated\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.get_actions!","page":"Simulation","title":"AutomotiveDrivingModels.get_actions!","text":"get_actions!(actions::Vector{A}, scene::EntityFrame{S,D,I}, roadway::R, models::Dict{I, M},) where {S,D,I,A,R,M<:DriverModel}\n\nFill in actions with the actions of each agent present in the scene. It calls observe! and rand for each driver models.  actions will contain the actions to apply to update the state of each vehicle.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.tick!","page":"Simulation","title":"AutomotiveDrivingModels.tick!","text":"tick!(scene::EntityFrame{S,D,I}, roadway::R, actions::Vector{A}, Δt::Float64) where {S,D,I,A,R}\n\nupdate scene in place by updating the state of each vehicle given their current action in actions.  It calls the propagate method for each vehicle in the scene.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#Callbacks-1","page":"Simulation","title":"Callbacks","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"One can define callback function that will be run at each simulation step. The callback function can interrupt the simulation if it return true. It is also useful to log simulation information. ","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"To implement a custom callback function you must implement a type and the associated run_callback method. Here is an example of a callback that checks if a vehicle longitudinal position has reached some goal position and stops the simulation if it is the case.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"struct ReachGoalCallback # a callback that checks if vehicle veh_id has reach a certain position \n    goal_pos::Float64\n    veh_id::Int64\nend \n\nfunction AutomotiveDrivingModels.run_callback(cb::ReachGoalCallback,\n    scenes::Vector{Scene},\n    roadway::R,\n    models::Dict{I,M},\n    tick::Int,\n    ) where {S,D,I,R,M<:DriverModel}\n    veh = get_by_id(last(scenes), cb.veh_id)\n    return veh.state.posF.s > cb.goal_pos \nend","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"A callback for collision is already implemented: CollisionCallback.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    run_callback\n    CollisionCallback","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.run_callback","page":"Simulation","title":"AutomotiveDrivingModels.run_callback","text":"run_callback(callback::Any, scenes::Vector{F}, roadway::R, models::Dict{I,M}, tick::Int) where {F,I,R,M<:DriverModel}    \nrun_callback(callback::Any, rec::EntityQueueRecord{S,D,I}, roadway::R, models::Dict{I,M}, tick::Int) where {S,D,I,R,M<:DriverModel}\n\nrun callback and return whether simlation should terminate A new method should be implemented when defining a new callback object.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveDrivingModels.CollisionCallback","page":"Simulation","title":"AutomotiveDrivingModels.CollisionCallback","text":"CollisionCallback\n\nTerminates the simulation once a collision occurs\n\n\n\n\n\n","category":"type"},{"location":"simulation/#Others-1","page":"Simulation","title":"Others","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    reset_hidden_states!","category":"page"},{"location":"simulation/#AutomotiveDrivingModels.reset_hidden_states!","page":"Simulation","title":"AutomotiveDrivingModels.reset_hidden_states!","text":"reset_hidden_states!(models::Dict{Int,M}) where {M<:DriverModel}\n\nreset hidden states of all driver models in models\n\n\n\n\n\n","category":"function"},{"location":"behaviors/#Behaviors-1","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These stands one level above the actions. They provide a higher level decision that the actions then implement in order to propagate the simulation forward.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"A behavior model can be interpreted as a control law. Given the current scene, representing all  the vehicles present in the environment, a behavior model returns an action to execute. ","category":"page"},{"location":"behaviors/#Interface-1","page":"Behaviors","title":"Interface","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"We provide an interface to interact with behavior model or implement your own. To implement your own driver model you can create a type that inherits from the abstract type DriverModel. Then you can implement the following methods:","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    DriverModel{DriveAction}\n    get_name(::DriverModel)\n    action_type(::DriverModel{A}) where A\n    set_desired_speed!(model::DriverModel, v_des::Float64)\n    reset_hidden_state!(model::DriverModel)\n    observe!(model::DriverModel, scene::EntityFrame{S,D,I}, roadway::R, egoid::Integer) where {S,D,I,R}\n    Base.rand(model::DriverModel)","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.DriverModel","page":"Behaviors","title":"AutomotiveDrivingModels.DriverModel","text":"DriverModel{DriveAction}\n\nA DriverModel represents a specific driving behavior.  It specifies the action taken by the agent at a given scene. The ation will be of type DriveAction. It can be interpreted as a distribution, the likelihood of taking a certain action  in a given scene.  The DriverModel type is an abstract type! Custom driver models should inherit from it.\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#AutomotiveDrivingModels.action_type-Union{Tuple{DriverModel{A}}, Tuple{A}} where A","page":"Behaviors","title":"AutomotiveDrivingModels.action_type","text":"action_type(::DriverModel{A}) where {A}\n\nreturns the type of the actions that are sampled from the model\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#Base.rand-Tuple{DriverModel}","page":"Behaviors","title":"Base.rand","text":"rand(model::DriverModel)\n\nSamples an action from the model.\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"observe! and rand are usually the most important methods to implement. observe! sets the model state in a given situation and rand allows to sample an action from the model.","category":"page"},{"location":"behaviors/#Available-Behaviors-1","page":"Behaviors","title":"Available Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    IntelligentDriverModel","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.IntelligentDriverModel","page":"Behaviors","title":"AutomotiveDrivingModels.IntelligentDriverModel","text":"IntelligentDriverModel <: LaneFollowingDriver\n\nThe Intelligent Driver Model. A rule based driving model that is governed by parameter settings. The output is an longitudinal acceleration.\n\nHere, we have extended IDM to the errorable IDM. If a standard deviation parameter is specified, then the output is a longitudinal acceleration sampled from a normal distribution around the non-errorable IDM output.\n\nFields\n\na::Float64 = NaN the predicted acceleration i.e. the output of the model\nσ::Float64 = NaN allows errorable IDM, optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk_spd::Float64 = 1.0 proportional constant for speed tracking when in freeflow [s⁻¹]\nδ::Float64 = 4.0 acceleration exponent\nT::Float64  = 1.5 desired time headway [s]\nv_des::Float64 = 29.0 desired speed [m/s]\ns_min::Float64 = 5.0 minimum acceptable gap [m]\na_max::Float64 = 3.0 maximum acceleration ability [m/s²]\nd_cmf::Float64 = 2.0 comfortable deceleration m/s²\nd_max::Float64 = 9.0 maximum deceleration m/s²\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    Tim2DDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.Tim2DDriver","page":"Behaviors","title":"AutomotiveDrivingModels.Tim2DDriver","text":"Tim2DDriver\n\nDriver that combines longitudinal driver and lateral driver into one model.\n\nConstructors\n\nTim2DDriver(timestep::Float64;mlon::LaneFollowingDriver=IntelligentDriverModel(), mlat::LateralDriverModel=ProportionalLaneTracker(), mlane::LaneChangeModel=TimLaneChanger(timestep),rec::SceneRecord = SceneRecord(1, timestep))\n\nFields\n\nrec::SceneRecord A record that will hold the resulting simulation results\nmlon::LaneFollowingDriver = IntelligentDriverModel() Longitudinal driving model\nmlat::LateralDriverModel = ProportionalLaneTracker() Lateral driving model\nmlane::LaneChangeModel =TimLaneChanger Lane change model\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    PrincetonDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.PrincetonDriver","page":"Behaviors","title":"AutomotiveDrivingModels.PrincetonDriver","text":"PrincetonDriver <: LaneFollowingDriver\n\nA lane following driver model that controls longitudinal speed by following a front car.\n\nFields\n\na::Float64\nσ::Float64 = NaN  optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    SidewalkPedestrianModel","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.SidewalkPedestrianModel","page":"Behaviors","title":"AutomotiveDrivingModels.SidewalkPedestrianModel","text":"SidewalkPedestrianModel\n\nWalks along the sidewalk until approaching the crosswalk. Waits for the cars to pass, then crosses.\n\nFields\n\ntimestep::Float64\nphase::Int = APPROACHING\nttc_threshold::Float64 = clamp(rand(Normal(4.0, 2.5)), 1.0, Inf)\ncrosswalk::Lane = Lane()\nsw_origin::Lane = Lane()\nsw_dest::Lane = Lane()\na::PedestrianLatLonAccel = PedestrianLatLonAccel(0.0, 0.0, sw_origin) makes you turn, left/right\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic\nv_des_approach::Float64 = clamp(rand(Normal(1.28, 0.18)), 0.0, Inf) Based on Feliciani et al. results\nv_des_appraise::Float64 = clamp(rand(Normal(0.94, 0.21)), 0.0, Inf)\nv_des_cross::Float64 = clamp(rand(Normal(1.35, 0.18)), 0.0, Inf)\nped_accel::Float64 = 0.30\nped_decel::Float64 = -0.50\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    StaticDriver","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.StaticDriver","page":"Behaviors","title":"AutomotiveDrivingModels.StaticDriver","text":"StaticDriver{A,P<:ContinuousMultivariateDistribution} <: DriverModel{A}\n\nA driver model where actions are always sampled by the same distribution specified  by the field distribution.\n\nFields\n\ndistribution::P\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Lane-change-helper-functions-1","page":"Behaviors","title":"Lane change helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used by the driver models to do lane changing and lateral control.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    MOBIL","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.MOBIL","page":"Behaviors","title":"AutomotiveDrivingModels.MOBIL","text":"MOBIL\n\nSee Treiber & Kesting, 'Modeling Lane-Changing Decisions with MOBIL'\n\nConstructor\n\nMOBIL(timestep::Float64;rec::SceneRecord=SceneRecord(2,timestep), mlon::LaneFollowingDriver=IntelligentDriverModel(),safe_decel::Float64=2.0,       politeness::Float64=0.35,advantage_threshold::Float64=0.1)\n\nFields\n\ndir::Int\nrec::SceneRecord\nmlon::LaneFollowingDriver=IntelligentDriverModel()\nsafe_decel::Float64=2.0\npoliteness::Float64=0.35\nadvantage_threshold::Float64=0.1\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    TimLaneChanger","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.TimLaneChanger","page":"Behaviors","title":"AutomotiveDrivingModels.TimLaneChanger","text":"TimLaneChanger\n\nA simple lane change behavior that changes lanes whenever the lead car is going slower than our desired speed. Lane changes are made when there is an available lane, fore/rear gaps exceed our thresholds, we are faster  than a rear vehicle in the target lane, and any lead vehicle in the target lane is faster than we can currently go.\n\nHas not been published anywhere, so first use in a paper would have to describe this. See MOBIL if you want a lane changer you can cite.\n\nConstructors\n\nTimLaneChanger(timestep::Float64;v_des::Float64=29.0,rec::SceneRecord=SceneRecord(2,timestep),threshold_fore::Float64 = 50.0,threshold_lane_change_gap_fore::Float64 = 10.0, threshold_lane_change_gap_rear::Float64 = 10.0,dir::Int=DIR_MIDDLE)\n\nFields\n\ndir::Int = DIR_MIDDLE the desired lane to go to eg: left,middle (i.e. stay in same lane) or right\nrec::SceneRecord TODO\nv_des::Float64 = 29.0 desired velocity\nthreshold_fore::Float64 = 50.0 Distance from lead vehicle\nthreshold_lane_change_gap_fore::Float64 = 10.0 Space in front\nthreshold_lane_change_gap_rear::Float64 = 10.0 Space rear\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalLaneTracker","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.ProportionalLaneTracker","page":"Behaviors","title":"AutomotiveDrivingModels.ProportionalLaneTracker","text":"ProportionalLaneTracker\n\nA controller that executes the lane change decision made by the lane change models\n\nConstructors\n\nProportionalLaneTracker(;σ::Float64 = NaN,kp::Float64 = 3.0,kd::Float64 = 2.0)\n\nFields\n\na::Float64 = NaN predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nkp::Float64 = 3.0 proportional constant for lane tracking\nkd::Float64 = 2.0 derivative constant for lane tracking\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Longitudinal-helper-functions-1","page":"Behaviors","title":"Longitudinal helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used to do longitudinal control by the driver models.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalSpeedTracker","category":"page"},{"location":"behaviors/#AutomotiveDrivingModels.ProportionalSpeedTracker","page":"Behaviors","title":"AutomotiveDrivingModels.ProportionalSpeedTracker","text":"ProportionalSpeedTracker <: LaneFollowingDriver\n\nLongitudinal proportional speed control.\n\nFields\n\na::Float64 = NaN  predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Roadways-1","page":"Roadways","title":"Roadways","text":"","category":"section"},{"location":"Roadways/#Data-Types-and-Accessing-Elements-1","page":"Roadways","title":"Data Types and Accessing Elements","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The data structure to represent roadways can be decomposed as follows:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Roadway The high level type containing all the information. It contains a list of RoadSegment.\nRoadSegment: a vector of lanes\nLane: A driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"represents a center line and a width. In addition it has attributed like speed limit. A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Lower level types:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Curves: A curve is a list of CurvePt\nCurvePt: the lowest level type. It represents a point on a curve by its global position, position along the curve, curvature at this point and derivative of the curvature at this point. Other types like CurveIndex or CurveProjection are used to identify a curve point along a curve. ","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Roadway\n      RoadSegment\n      move_along","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Roadway","page":"Roadways","title":"AutomotiveDrivingModels.Roadway","text":"Roadway\n\nThe main datastructure to represent road network, it consists of a list of RoadSegment\n\nFields\n\nsegments::Vector{RoadSegment}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.RoadSegment","page":"Roadways","title":"AutomotiveDrivingModels.RoadSegment","text":"RoadSegment{T}\n\na list of lanes forming a single road with a common direction\n\nFields\n\nid::Int64\nlanes::Vector{Lane{T}} lanes are stored right to left\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.move_along","page":"Roadways","title":"AutomotiveDrivingModels.move_along","text":"move_along(roadind::RoadIndex, road::Roadway, Δs::Float64)\n\nReturn the RoadIndex at ind's s position + Δs\n\n\n\n\n\nmove_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Roadway-generation-1","page":"Roadways","title":"Roadway generation","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"AutomotiveDrivingModels.jl provide high level functions to generate road networks by drawing straight road segment and circular curves. Two predefined road network can be generated easily: multi-lane straight roadway sections and a multi-lane stadium shaped roadway.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      gen_straight_curve\n      gen_straight_segment\n      gen_bezier_curve\n      gen_straight_roadway\n      gen_stadium_roadway","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_curve","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_curve","text":"gen_straight_curve(A::VecE2{T}, B::VecE2{T}, nsamples::Integer) where T<:Real\n\nReturns a Curve corresponding to a straight line between A and B. nsamples indicates the number of points to place between A and B, if set to two, the curve will only contains A and B.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_segment","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_segment","text":"gen_straight_segment(seg_id::Integer, nlanes::Integer, length::Float64=1000.0;\n\nGenerate a straight RoadSegment with nlanes number of lanes of length length.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_bezier_curve","page":"Roadways","title":"AutomotiveDrivingModels.gen_bezier_curve","text":"gen_bezier_curve(A::VecSE2{T}, B::VecSE2{T}, rA::T, rB::T, nsamples::Int) where T <: Real\n\nGenerate a Bezier curve going from A to B with radii specified by rA and rB. It uses cubic interpolation. nsamples specifies the number of point along the curve between A and B. The more  points, the more accurate the approximation is. This is useful to generate arcs. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_straight_roadway","page":"Roadways","title":"AutomotiveDrivingModels.gen_straight_roadway","text":"gen_straight_roadway(nlanes::Int, length::Float64)\n\nGenerate a roadway with a single straight segment whose rightmost lane center starts at starts at (0,0), and proceeds in the positive x direction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.gen_stadium_roadway","page":"Roadways","title":"AutomotiveDrivingModels.gen_stadium_roadway","text":"gen_stadium_roadway(nlanes::Int; length::Float64=100.0; width::Float64=10.0; radius::Float64=25.0)\n\nGenerate a roadway that is a rectangular racetrack with rounded corners.     length = length of the x-dim straight section for the innermost (leftmost) lane [m]     width  = length of the y-dim straight section for the innermost (leftmost) lane [m]     radius = turn radius [m]\n\n  ______________________\n /                      \\ \n|                        |\n|                        |\n\\______________________/\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Lane-1","page":"Roadways","title":"Lane","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Lane data structure represent a driving lane in the roadway. The default lane width is 3m. It contains all the low level geometry information.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Lane\n      LaneTag\n      lanes\n      lanetags\n      SpeedLimit\n      LaneBoundary\n      LaneConnection\n      is_in_exits\n      is_in_entrances\n      connect!\n      is_between_segments_hi\n      is_between_segments\n      has_segment\n      has_lanetag\n      next_lane\n      prev_lane\n      has_next\n      has_prev\n      next_lane_point\n      prev_lane_point\n      n_lanes_left\n      n_lanes_right","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Lane","page":"Roadways","title":"AutomotiveDrivingModels.Lane","text":"Lane\n\nA driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which represents a center line and a width. In addition it has attributed like speed limit.  A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.\n\nFields\n\ntag::LaneTag\ncurve::Curve\nwidth::Float64  [m]\nspeed_limit::SpeedLimit\nboundary_left::LaneBoundary\nboundary_right::LaneBoundary\nexits::Vector{LaneConnection} # list of exits; put the primary exit (at end of lane) first\nentrances::Vector{LaneConnection} # list of entrances; put the primary entrance (at start of lane) first\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneTag","page":"Roadways","title":"AutomotiveDrivingModels.LaneTag","text":"LaneTag\n\nAn identifier for a lane. The lane object can be retrieved by indexing the roadway by the lane tag:\n\ntag = LaneTag(1, 2) # second lane segment 1\nlane = roadway[tag] # returns a Lane object\n\nFields\n\nsegment::Int64 segment id\nlane::Int64 index in segment.lanes of this lane\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.lanes","page":"Roadways","title":"AutomotiveDrivingModels.lanes","text":"lanes(roadway::Roadway{T}) where T\n\nreturn a list of all the lanes present in roadway. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.lanetags","page":"Roadways","title":"AutomotiveDrivingModels.lanetags","text":"lanetags(roadway::Roadway)\n\nreturn a list of all the lane tags present in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.SpeedLimit","page":"Roadways","title":"AutomotiveDrivingModels.SpeedLimit","text":"SpeedLimit\n\nDatastructure to represent a speed limit\n\nFields\n\nlo::Float64 [m/s] lower speed limit \nhi::Float64 [m/s] higher speed limit\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneBoundary","page":"Roadways","title":"AutomotiveDrivingModels.LaneBoundary","text":"LaneBoundary\n\nData structure to represent lanes boundaries such as double yellow lines.\n\nFields\n\n- `style::Symbol` ∈ :solid, :broken, :double\n- `color::Symbol` ∈ :yellow, white\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.LaneConnection","page":"Roadways","title":"AutomotiveDrivingModels.LaneConnection","text":"LaneConnection{I <: Integer, T <: Real}\n\nData structure to specify the connection of a lane. It connects mylane to the point target.  target would typically be the starting point of a new lane.\n\ndownstream::Bool\nmylane::CurveIndex{I,T}\ntarget::RoadIndex{I,T}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.is_in_exits","page":"Roadways","title":"AutomotiveDrivingModels.is_in_exits","text":"is_in_exits(lane::Lane, target::LaneTag)\n\nreturns true if target is in the exit lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_in_entrances","page":"Roadways","title":"AutomotiveDrivingModels.is_in_entrances","text":"is_in_entrances(lane::Lane, target::LaneTag)\n\nreturns true if target is in the entrances lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.connect!","page":"Roadways","title":"AutomotiveDrivingModels.connect!","text":"connect!(source::Lane, dest::Lane)\n\nconnect two lanes to each other. Useful for roadway construction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_between_segments_hi","page":"Roadways","title":"AutomotiveDrivingModels.is_between_segments_hi","text":"is_between_segments_hi(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.is_between_segments","page":"Roadways","title":"AutomotiveDrivingModels.is_between_segments","text":"is_between_segments(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_segment","page":"Roadways","title":"AutomotiveDrivingModels.has_segment","text":"has_segment(roadway::Roadway, segid::Int)\n\nreturns true if segid is in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_lanetag","page":"Roadways","title":"AutomotiveDrivingModels.has_lanetag","text":"has_lanetag(roadway::Roadway, tag::LaneTag)\n\nreturns true if roadway contains a lane identified by tag\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.next_lane","page":"Roadways","title":"AutomotiveDrivingModels.next_lane","text":"next_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the end lane. If lane has several exits, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.prev_lane","page":"Roadways","title":"AutomotiveDrivingModels.prev_lane","text":"prev_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the beginning lane. If lane has several entrances, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_next","page":"Roadways","title":"AutomotiveDrivingModels.has_next","text":"has_next(lane::Lane)\n\nreturns true if the end of the lane is connected to another lane (i.e. if it has an exit lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.has_prev","page":"Roadways","title":"AutomotiveDrivingModels.has_prev","text":"has_prev(lane::Lane)\n\nreturns true if another lane is connected to the beginning of that lane. (i.e. if it has an entrance lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.next_lane_point","page":"Roadways","title":"AutomotiveDrivingModels.next_lane_point","text":"next_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first exit\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.prev_lane_point","page":"Roadways","title":"AutomotiveDrivingModels.prev_lane_point","text":"prev_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first entrance\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.n_lanes_left","page":"Roadways","title":"AutomotiveDrivingModels.n_lanes_left","text":"n_lanes_left(lane::Lane, roadway::Roadway)\n\nreturns the number of lanes to the left of lane\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.n_lanes_right","page":"Roadways","title":"AutomotiveDrivingModels.n_lanes_right","text":"n_lanes_right(lane::Lane, roadway::Roadway)\n\nreturns the number of lanes to the right of lane\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Frenet-frame-1","page":"Roadways","title":"Frenet frame","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Frenet frame is a lane relative frame to represent a position on the road network.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Frenet\n      get_posG","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Frenet","page":"Roadways","title":"AutomotiveDrivingModels.Frenet","text":"Frenet\n\nRepresents a vehicle position and heading in a lane relative frame. \n\nConstructors\n\nFrenet(roadind::RoadIndex, roadway::Roadway; t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(roadproj::RoadProjection, roadway::Roadway)\nFrenet(lane::Lane, s::Float64, t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(posG::VecSE2, roadway::Roadway)\nFrenet(posG::VecSE2, lane::Lane, roadway::Roadway)\n\nFields\n\nroadind: road index\ns: distance along lane\nt: lane offset, positive is to left. zero point is the centerline of the lane.\nϕ: lane relative heading\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Accessing-objects-and-projections-1","page":"Roadways","title":"Accessing objects and projections","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The main roadway object can be indexed by different object to access different elements such as lane or curve points:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"LaneTag: indexing roadway by a lane tag will return the lane associated to the lane tag \nRoadIndex: indexing roadway by a road index will return the curve point associated to this index","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"  RoadIndex\n  CurveIndex\n  RoadProjection\n  proj(posG::VecSE2{T}, lane::Lane, roadway::Roadway;move_along_curves::Bool = true ) where T<: Real\n  proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T<: Real\n  proj(posG::VecSE2{T}, roadway::Roadway) where T<: Real\n  Base.getindex(lane::Lane, ind::CurveIndex, roadway::Roadway)\n  Base.getindex(roadway::Roadway, segid::Int)\n  Base.getindex(roadway::Roadway, tag::LaneTag)","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.RoadIndex","page":"Roadways","title":"AutomotiveDrivingModels.RoadIndex","text":"RoadIndex{I <: Integer, T <: Real}\n\nA data structure to index points in a roadway. Calling roadway[roadind] will return the point associated to the road index.\n\nFields\n\nind::CurveIndex{I,T} the index of the point in the curve\ntag::LaneTag the lane tag of the point\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurveIndex","page":"Roadways","title":"AutomotiveDrivingModels.CurveIndex","text":"CurveIndex{I <: Integer, T <: Real}\n\nGiven a Curve object curve one can call curve[ind] where ind is a CurveIndex. The field t can be used to interpolate between two  points in the curve. \n\nFields\n\ni::I` index in the curve , ∈ [1:length(curve)-1]\nt::T ∈ [0,1] for linear interpolation\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.RoadProjection","page":"Roadways","title":"AutomotiveDrivingModels.RoadProjection","text":"RoadProjection{I <: Integer, T <: Real}\n\nrepresents the projection of a point on the roadway\n\nFields\n\ncurveproj::CurveProjection{I, T}\ntag::LaneTag\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},RoadSegment,Roadway}} where T<:Real","page":"Roadways","title":"Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the segment. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},Roadway}} where T<:Real","page":"Roadways","title":"Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the roadway. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,Int64}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, segid::Int)\n\nreturns the segment associated with id segid\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,LaneTag}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, tag::LaneTag)\n\nreturns the lane identified by the tag LaneTag\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Low-level-1","page":"Roadways","title":"Low level","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Curve\n      CurvePt\n      CurveProjection\n      is_at_curve_end\n      get_lerp_time\n      index_closest_to_point\n      get_curve_index\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, D::VecE2{T}, t::T) where T<:Real\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, t::T) where T<:Real","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.Curve","page":"Roadways","title":"AutomotiveDrivingModels.Curve","text":"Curve{T}\n\nis a vector of curve points\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurvePt","page":"Roadways","title":"AutomotiveDrivingModels.CurvePt","text":"CurvePt{T}\n\ndescribes a point on a curve, associated with a curvature and the derivative of the curvature\n\npos::VecSE2{T} # global position and orientation\ns::T  # distance along the curve\nk::T # curvature\nkd::T # derivative of curvature\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.CurveProjection","page":"Roadways","title":"AutomotiveDrivingModels.CurveProjection","text":"CurveProjection{I <: Integer, T <: Real}\n\nThe result of a point projected to a Curve\n\nFields\n\nind::CurveIndex{I, T}\nt::T lane offset \nϕ::T lane-relative heading [rad]\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.is_at_curve_end","page":"Roadways","title":"AutomotiveDrivingModels.is_at_curve_end","text":"is_at_curve_end(ind::CurveIndex, curve::Curve)\n\nreturns true if the curve index is at the end of the curve\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_lerp_time","page":"Roadways","title":"AutomotiveDrivingModels.get_lerp_time","text":"get_lerp_time(A::VecE2, B::VecE2, Q::VecE2)\n\nGet lerp time t∈[0,1] such that lerp(A, B) is as close as possible to Q\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.index_closest_to_point","page":"Roadways","title":"AutomotiveDrivingModels.index_closest_to_point","text":"index_closest_to_point(curve::Curve, target::AbstractVec)\n\nreturns the curve index closest to the point described by target. target must be [x, y].\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_curve_index","page":"Roadways","title":"AutomotiveDrivingModels.get_curve_index","text":"get_curve_index(curve::Curve{T}, s::T) where T <: Real\n\nReturn the CurveIndex for the closest s-location on the curve\n\n\n\n\n\nget_curve_index(ind::CurveIndex, curve::Curve, Δs::T) where T <: Real\n\nReturn the CurveIndex at ind's s position + Δs\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"Vec.lerp","text":"cubic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"Vec.lerp","text":"quadratic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#D-roadway-1","page":"Roadways","title":"1D roadway","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      StraightRoadway\n      mod_position_to_roadway\n      get_headway","category":"page"},{"location":"Roadways/#AutomotiveDrivingModels.StraightRoadway","page":"Roadways","title":"AutomotiveDrivingModels.StraightRoadway","text":"StraightRoadway\n\nA simple type representing a one lane, one dimensional straight roadway\n\nFields\n\nlength::Float64\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveDrivingModels.mod_position_to_roadway","page":"Roadways","title":"AutomotiveDrivingModels.mod_position_to_roadway","text":"mod_position_to_roadway(s::Float64, roadway::StraightRoadway)\n\nperforms a modulo of the position s with the length of roadway\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveDrivingModels.get_headway","page":"Roadways","title":"AutomotiveDrivingModels.get_headway","text":"get_headway(s_rear::Float64, s_fore::Float64, roadway::StraightRoadway)\n\nreturns a positive distance between srear and sfore.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Read-and-Write-roadways-1","page":"Roadways","title":"Read and Write roadways","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Base.read(io::IO, ::MIME\"text/plain\", ::Type{Roadway})\n      Base.write(io::IO, ::MIME\"text/plain\", roadway::Roadway)","category":"page"},{"location":"Roadways/#Base.read-Tuple{IO,MIME{Symbol(\"text/plain\")},Type{Roadway}}","page":"Roadways","title":"Base.read","text":"Base.read(io::IO, ::MIME\"text/plain\", ::Type{Roadway})\n\nextract roadway information from a text file and returns a roadway object.\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.write-Tuple{IO,MIME{Symbol(\"text/plain\")},Roadway}","page":"Roadways","title":"Base.write","text":"Base.write(io::IO, ::MIME\"text/plain\", roadway::Roadway)\n\nwrite all the roadway information to a text file\n\n\n\n\n\n","category":"method"},{"location":"actions/#Driving-Actions-1","page":"Driving Actions","title":"Driving Actions","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"In the driving stack, the actions lie one level below the behaviors. While the behaviors provide the high level decision making, the actions enable the execution of these decisions in the simulation.","category":"page"},{"location":"actions/#Interface-1","page":"Driving Actions","title":"Interface","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    propagate","category":"page"},{"location":"actions/#AutomotiveDrivingModels.propagate","page":"Driving Actions","title":"AutomotiveDrivingModels.propagate","text":"propagate(veh::Entity{S,D,I}, action::A, roadway::R, Δt::Float64) where {S,D,I,A,R}\n\nTake an entity of type {S,D,I} and move it over Δt seconds to produce a new entity based on the action on the given roadway.\n\n\n\n\n\nPropagate vehicle forward in time using a desired acceleration and turn rate\n\n\n\n\n\npropagate(veh::Entity{VehicleState,D,I}, action::AccelDesang, roadway::Roadway, Δt::Float64; n_integration_steps::Int=4) where {D,I}\n\nPropagate vehicle forward in time using a desired acceleration and heading angle\n\n\n\n\n\npropagate vehicle forward in time given a desired acceleration and steering angle. If steering angle higher than 0.1 radian, the vehicle drives in a circle\n\n\n\n\n\n","category":"function"},{"location":"actions/#Action-types-available-1","page":"Driving Actions","title":"Action types available","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelDesang","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelDesang","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelDesang","text":"AccelDesang\n\nAn action type with a longitudinal acceleration and a desired heading angle\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nϕdes::Float64 desired heading angle\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelSteeringAngle","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelSteeringAngle","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelSteeringAngle","text":"AccelSteeringAngle\n\nAllows driving the car in a circle based on the steering angle If steering angle less than threshold 0.01 radian, just drives straight\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nδ::Float64 Steering angle [rad]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelTurnrate","category":"page"},{"location":"actions/#AutomotiveDrivingModels.AccelTurnrate","page":"Driving Actions","title":"AutomotiveDrivingModels.AccelTurnrate","text":"AccelTurnrate\n\nAn action type with a longitudinal acceleration and a turn rate\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nω::Float64 desired turn rate [rad/sec]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LaneFollowingAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.LaneFollowingAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.LaneFollowingAccel","text":"LaneFollowingAccel\n\nLongitudinal acceleration\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LatLonAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.LatLonAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.LatLonAccel","text":"LatLonAccel\n\nAcceleration in the frenet frame\n\nFields\n\na_lat::Float64 Lateral acceleration [m/s^2]\na_lon::Float64 Longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    PedestrianLatLonAccel","category":"page"},{"location":"actions/#AutomotiveDrivingModels.PedestrianLatLonAccel","page":"Driving Actions","title":"AutomotiveDrivingModels.PedestrianLatLonAccel","text":"PedestrianLatLonAccel\n\nPedestrian walking action. Acceleration in the Frenet frame, along with desired lane after crossing the street.\n\nFields\n\na_lat::Float64 lateral acceleration [m/s^2]\na_lon::Float64 longitudinal accelaration [m/s^2]\nlane_des::Lane desired lane to move to\n\n\n\n\n\n","category":"type"},{"location":"states/#States-1","page":"States","title":"States","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"In this section of the documentation we explain the default vehicle state type provided by AutomotiveDrivingModels as well as the data types used to represent a driving scene. Most of the underlying structures are defined in Records.jl.  The data structures provided in ADM.jl are concrete instances of parametric types defined in Records. It is possible in principle to define your custom state definition and use the interface defined in ADM.jl.","category":"page"},{"location":"states/#Entity-state-1","page":"States","title":"Entity state","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Entities are represented by the Entity data type provided by Records.jl (https://github.com/sisl/Records.jl/blob/master/src/entities.jl). The Entity data type has three fields: a state, a definition and an id. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"The state of an entity usually describes physical quantity such as position and velocity. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"Two state data structures are provided.","category":"page"},{"location":"states/#Defining-your-own-state-type-1","page":"States","title":"Defining your own state type","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"You can define your own state type if the provided VehicleState does not contain the right information. There are a of couple functions that need to be defined such that other functions in AutomotiveDrivingModels can work smoothly with your custom state type.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    posg\n    posf\n    vel\n    velf\n    velg","category":"page"},{"location":"states/#AutomotiveDrivingModels.posg","page":"States","title":"AutomotiveDrivingModels.posg","text":"posg(state)\n\nreturns the coordinates of the state in the global (world) frame. The return type is expected to be a VecSE2.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.posf","page":"States","title":"AutomotiveDrivingModels.posf","text":"posf(state)\n\nreturns the coordinates of the state in the Frenet frame.  The return type is expected to be Frenet.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.vel","page":"States","title":"AutomotiveDrivingModels.vel","text":"vel(state)\n\nreturns the norm of the longitudinal velocity.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.velf","page":"States","title":"AutomotiveDrivingModels.velf","text":"velf(state)\n\nreturns the velocity of the state in the Frenet frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.velg","page":"States","title":"AutomotiveDrivingModels.velg","text":"velg(state)\n\nreturns the velocity of the state in the global (world) frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#","page":"States","title":"States","text":"Example of a custom state type containing acceleration:","category":"page"},{"location":"states/#","page":"States","title":"States","text":"\n# you can use composition to define your custom state type based on existing ones\nstruct MyVehicleState\n    veh::VehicleState\n    acc::Float64\nend\n\n# define the functions from the interface \nposg(s::MyVehicleState) = posg(s.veh) # those functions are implemented for the `VehicleState` type\nposf(s::MyVehicleState) = posf(s.veh)\nvelg(s::MyVehicleState) = velg(s.veh)\nvelf(s::MyVehicleState) = velf(s.veh)\nvel(s::MyVehicleState) = vel(s.veh)","category":"page"},{"location":"states/#D-states-and-vehicles-1","page":"States","title":"1D states and vehicles","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"    State1D\n    Vehicle1D","category":"page"},{"location":"states/#AutomotiveDrivingModels.State1D","page":"States","title":"AutomotiveDrivingModels.State1D","text":"State1D\n\nA data type to represent one dimensional states\n\nFields\n\n- `s::Float64` position \n- `v::Float64` speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.Vehicle1D","page":"States","title":"AutomotiveDrivingModels.Vehicle1D","text":"Vehicle1D\n\nA specific instance of the Entity type defined in Records.jl to represent vehicles in 1d environments.\n\n\n\n\n\n","category":"type"},{"location":"states/#D-states-and-vehicles-2","page":"States","title":"2D states and vehicles","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Here we list useful functions to interact with vehicle states and retrieve interesting information like the position of the front of the vehicle or the lane to which the vehicle belongs.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    VehicleState\n    Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n    move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64; ϕ₂::Float64=vehstate.posF.ϕ, ::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n    Vehicle\n    get_front\n    get_rear\n    get_center\n    get_footpoint\n    get_lane\n    Base.convert(::Type{Vehicle}, veh::Entity{VehicleState, D, Int64}) where D<:AbstractAgentDefinition","category":"page"},{"location":"states/#AutomotiveDrivingModels.VehicleState","page":"States","title":"AutomotiveDrivingModels.VehicleState","text":"VehicleState\n\nA default type to represent an agent physical state (position, velocity). It contains the position in the global frame, Frenet frame and the longitudinal velocity\n\nconstructors\n\nVehicleState(posG::VecSE2{Float64}, v::Float64) \nVehicleState(posG::VecSE2{Float64}, roadway::Roadway, v::Float64)\nVehicleState(posG::VecSE2{Float64}, lane::Lane, roadway::Roadway, v::Float64)\nVehicleState(posF::Frenet, roadway::Roadway, v::Float64)\n\nfields\n\nposG::VecSE2{Float64} global position\nposF::Frenet lane relative position\nv::Float64 longitudinal velocity\n\n\n\n\n\n","category":"type"},{"location":"states/#Vec.lerp-Tuple{VehicleState,VehicleState,Float64,Roadway}","page":"States","title":"Vec.lerp","text":"Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n\nPerform linear interpolation of the two vehicle states. Returns a VehicleState.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveDrivingModels.move_along-Tuple{VehicleState,Roadway,Float64}","page":"States","title":"AutomotiveDrivingModels.move_along","text":"move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveDrivingModels.Vehicle","page":"States","title":"AutomotiveDrivingModels.Vehicle","text":"Vehicle\n\nA specific instance of the Entity type defined in Records to represent Vehicles with  state VehicleState , definition VehicleDef and id Int64\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.get_front","page":"States","title":"AutomotiveDrivingModels.get_front","text":"get_front(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the front of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_rear","page":"States","title":"AutomotiveDrivingModels.get_rear","text":"get_rear(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the rear of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_center","page":"States","title":"AutomotiveDrivingModels.get_center","text":"get_center(veh::Entity{VehicleState, D, I})\n\nreturns the position of the center of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_footpoint","page":"States","title":"AutomotiveDrivingModels.get_footpoint","text":"get_footpoint(veh::Entity{VehicleState, D, I})\n\nreturns the position of the footpoint of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveDrivingModels.get_lane","page":"States","title":"AutomotiveDrivingModels.get_lane","text":"get_lane(roadway::Roadway, vehicle::Entity{S, D, I})\nget_lane(roadway::Roadway, vehicle::VehicleState)\n\nreturn the lane where vehicle is in.\n\n\n\n\n\n","category":"function"},{"location":"states/#Base.convert-Union{Tuple{D}, Tuple{Type{Entity{VehicleState,VehicleDef,Int64}},Entity{VehicleState,D,Int64}}} where D<:AbstractAgentDefinition","page":"States","title":"Base.convert","text":"Base.convert(::Type{Vehicle}, veh::Entity{VehicleState, D, Int64}) where D<:AbstractAgentDefinition\n\nConverts an entity in Vehicle (it is converting the agent definition only)\n\n\n\n\n\n","category":"method"},{"location":"states/#Scenes-1","page":"States","title":"Scenes","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"A Scene represents a collection of vehicles at a given time. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    Scene\n    SceneRecord\n    Trajdata","category":"page"},{"location":"states/#AutomotiveDrivingModels.Scene","page":"States","title":"AutomotiveDrivingModels.Scene","text":"Scene\n\nA Scene is a specific instance of the Frame type defined in Records. It represents a collection of vehicles at a given time.\n\nConstructors\n\n- `Scene(n::Int=100)`\n- `Scene(arr::Vector{Vehicle})`\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.SceneRecord","page":"States","title":"AutomotiveDrivingModels.SceneRecord","text":"SceneRecord\n\nA SceneRecord is a specific instance of the QueueRecord type defined in Records.jl. It represents a collection of Scenes.\n\nconstructor\n\nSceneRecord(capacity::Int, timestep::Float64, frame_capacity::Int=100)\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveDrivingModels.Trajdata","page":"States","title":"AutomotiveDrivingModels.Trajdata","text":"Trajdata\n\nTrajdata is a specific instance of ListRecord defined in Records.jl. It is a collection of Scenes\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#Collision-Checker-1","page":"Collision Checker","title":"Collision Checker","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"There are two collisions checkers currently available in AutomotiveDrivingModels.jl.  The first collision checker is accessible through the function is_colliding and relies on Minkowski sum.  The second one is accessible through collision_checker and uses the parallel axis theorem. The latter is a bit faster.  A benchmark script is available in test/collision_checkers_benchmark.jl and relies on static arrays. ","category":"page"},{"location":"collision_checkers/#Parallel-Axis-Theorem-1","page":"Collision Checker","title":"Parallel Axis Theorem","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"This collision checker relies on the parallel axis theorem. It checks that two convex polygon overlap","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    collision_checker","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.collision_checker","page":"Collision Checker","title":"AutomotiveDrivingModels.collision_checker","text":"collision_checker(veh_a::Entity, veh_b::Entity)\ncollision_checker(veh_a, veh_b, veh_a_def::AbstractAgentDefinition, veh_b_def::AbstractAgentDefinition)\n\nreturn True if veh_a and veh_b collides. Relies on the parallel axis theorem.\n\n\n\n\n\ncollision_checker(scene::Frame{Entity{S,D,I}}, egoid::I) where {S, D<:AbstractAgentDefinition, I}\n\nreturn true if any entity in the scene collides with the entity of id egoid.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Vehicles can be converted to polygon (static matrices containing four vertices).","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    polygon","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.polygon","page":"Collision Checker","title":"AutomotiveDrivingModels.polygon","text":"polygon(pos::VecSE2{Float64}, veh_def::AbstractAgentDefinition)\npolygon(x::Float64,y::Float64,theta::Float64, length::Float64, width::Float64)\n\nreturns a 4x2 static matrix corresponding to a rectangle around a car centered at pos and of dimensions specified by veh_def\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#Minkowski-Sum-1","page":"Collision Checker","title":"Minkowski Sum","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Here are the methods available using Minkowski sum.","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    is_colliding\n    ConvexPolygon\n    CPAMemory\n    CollisionCheckResult\n    to_oriented_bounding_box!\n    get_oriented_bounding_box\n    is_potentially_colliding\n    get_collision_time\n    get_first_collision\n    is_collision_free\n    get_distance\n    get_edge","category":"page"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_colliding","page":"Collision Checker","title":"AutomotiveDrivingModels.is_colliding","text":"is_colliding(ray::VecSE2{Float64}, poly::ConvexPolygon)\n\nreturns true if the ray collides with the polygon\n\n\n\n\n\nis_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns true if the vehicles A and B are colliding. It uses Minkowski sums.     is_colliding(mem::CPAMemory) returns true if vehA and vehB in mem collides.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.ConvexPolygon","page":"Collision Checker","title":"AutomotiveDrivingModels.ConvexPolygon","text":"ConvexPolygon\nConvexPolygon(npts::Int)\nConvexPolygon(pts::Vector{VecE2{Float64}})\n\nMutable structure to represent a convex polygon. It is used by the Minkowski sum collision checker\n\nFields\n\npts::Vector{VecE2{Float64}}\nnpts::Int\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.CPAMemory","page":"Collision Checker","title":"AutomotiveDrivingModels.CPAMemory","text":"CPAMemory\n\nA structure to cache the bounding boxes around vehicle. It is part of the internals of the  Minkowski collision checker.\n\nFields\n\nvehA::ConvexPolygon bounding box for vehicle A\nvehB::ConvexPolygon bounding box for vehicle B\nmink::ConvexPolygon minkowski bounding box\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.CollisionCheckResult","page":"Collision Checker","title":"AutomotiveDrivingModels.CollisionCheckResult","text":"CollisionCheckResult\n\nA type to store the result of a collision checker\n\nFields\n\nis_colliding::Bool\nA::Int64 # index of 1st vehicle\nB::Int64 # index of 2nd vehicle\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveDrivingModels.to_oriented_bounding_box!","page":"Collision Checker","title":"AutomotiveDrivingModels.to_oriented_bounding_box!","text":"to_oriented_bounding_box!(retval::ConvexPolygon, center::VecSE2{Float64}, len::Float64, wid::Float64)\nto_oriented_bounding_box!(retval::ConvexPolygon, veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))\n\nFills in the vertices of retval according to the rectangle specification: center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_oriented_bounding_box","page":"Collision Checker","title":"AutomotiveDrivingModels.get_oriented_bounding_box","text":"get_oriented_bounding_box(center::VecSE2{Float64}, len::Float64, wid::Float64) = to_oriented_bounding_box!(ConvexPolygon(4), center, len, wid)\nget_oriented_bounding_box(veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))  where {S,D<:AbstractAgentDefinition,I}\n\nReturns a ConvexPolygon representing a bounding rectangle of the size specified by center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_potentially_colliding","page":"Collision Checker","title":"AutomotiveDrivingModels.is_potentially_colliding","text":"is_potentially_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}) where {S,D<:AbstractAgentDefinition,I}\n\nA fast collision check to remove things clearly not colliding\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_collision_time","page":"Collision Checker","title":"AutomotiveDrivingModels.get_collision_time","text":"get_collision_time(ray::VecSE2{Float64}, poly::ConvexPolygon, ray_speed::Float64)\n\nreturns the collision time between a ray and a polygon given ray_speed\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_first_collision","page":"Collision Checker","title":"AutomotiveDrivingModels.get_first_collision","text":"get_first_collision(scene::EntityFrame{S,D,I}, target_index::Int, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between a vehicle and scene[target_index]\n\n\n\n\n\nget_first_collision(scene::EntityFrame{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles in vehicle_indeces.\n\n\n\n\n\nget_first_collision(scene::EntityFrame{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.is_collision_free","page":"Collision Checker","title":"AutomotiveDrivingModels.is_collision_free","text":"is_collision_free(scene::EntityFrame{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\nis_collision_free(scene::EntityFrame{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nCheck that there is no collisions between any two vehicles in scene\n\nIf vehicle_indeces is used, it only checks for vehicles within scene[vehicle_indeces]\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#Vec.get_distance","page":"Collision Checker","title":"Vec.get_distance","text":"Vec.get_distance(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns the euclidean distance between A and B.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveDrivingModels.get_edge","page":"Collision Checker","title":"AutomotiveDrivingModels.get_edge","text":"get_edge(pts::Vector{VecE2{Float64}}, i::Int, npts::Int=length(pts))\n\nreturns the ith edge in pts\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#Feature-Extraction-[WIP]-1","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"AutomotiveDrivingModels.jl implements a feature extraction pipeline to extract information from pre-recorded simulation  in a QueueRecord or ListRecord. (see Records.jl for info on the data structure)","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"PRs for documenting feature extraction are more than welcome","category":"page"},{"location":"feature_extraction/#Neighbors-Features-1","page":"Feature Extraction [WIP]","title":"Neighbors Features","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"Here is a list of function to retrieve information about the neighbors of a given vehicle. ","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"    NeighborLongitudinalResult\n    get_neighbor_fore_along_lane\n    get_neighbor_fore_along_left_lane\n    get_neighbor_fore_along_right_lane\n    get_neighbor_rear_along_lane\n    get_neighbor_rear_along_left_lane\n    get_neighbor_rear_along_right_lane\n    FrenetRelativePosition\n    get_frenet_relative_position","category":"page"},{"location":"feature_extraction/#AutomotiveDrivingModels.NeighborLongitudinalResult","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.NeighborLongitudinalResult","text":"NeighborLongitudinalResult\n\nA structure to retrieve information about a neihbor in the longitudinal direction i.e. rear and front neighbors on the same lane. If the neighbor index is equal to nothing it means there is no neighbor.\n\nFields\n\nind::Union{Nothing, Int64} index of the neighbor in the scene\nΔs::Float64 positive distance along the lane between vehicles positions\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_neighbor_fore_along_lane","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_neighbor_fore_along_lane","text":"get_neighbor_fore_along_lane(scene::EntityFrame{S,D,I}, roadway::Roadway, tag_start::LaneTag, s_base::Float64, targetpoint_primary::VehicleTargetPoint, targetpoint_valid::VehicleTargetPoint;\n                             max_distance_fore::Float64 = 250.0, index_to_ignore::Int=-1) where {S,D<:AbstractAgentDefinition,I}\n\nReturn the index and the longitudinal distance of the vehicle that is in the same lane as scene[vehicleindex] and in front of it with the smallest distance along the lane. The result is returned as a NeighborLongitudinalResult object. The method will search on the current lane first, and if no vehicle is found it will continue to travel along the lane following nextlane(lane, roadway). If no vehicle is found within max_distance_fore, the index takes a value of nothing.\n\nNotes on the optional arguments:\n\ntargetpoint_primary::VehicleTargetPoint the reference point whose distance we want to minimize\ntargetpoint_valid::VehicleTargetPoint the reference point, which if distance to is positive, we include the vehicle\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.FrenetRelativePosition","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.FrenetRelativePosition","text":"Project the given point to the same lane as the given RoadIndex.\n\nThis will return the projection of the point, along with the Δs along the lane from the RoadIndex.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#Lane-Features-1","page":"Feature Extraction [WIP]","title":"Lane Features","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction [WIP]","title":"Feature Extraction [WIP]","text":"    get_lane_width\n    get_markerdist_left\n    get_markerdist_right","category":"page"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_lane_width","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_lane_width","text":"get_lane_width(veh::Entity, roadway::Roadway)\n\nReturns the width of the lane where veh is.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_markerdist_left","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_markerdist_left","text":"get_markerdist_left(veh::Entity, roadway::Roadway)\n\ndistance of veh to the left marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveDrivingModels.get_markerdist_right","page":"Feature Extraction [WIP]","title":"AutomotiveDrivingModels.get_markerdist_right","text":"get_markerdist_left(veh::Entity, roadway::Roadway)\n\ndistance of veh to the right marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"#","page":"About","title":"About","text":"This is the documentation for AutomotiveDrivingModels.jl. ","category":"page"},{"location":"#Concepts-1","page":"About","title":"Concepts","text":"","category":"section"},{"location":"#","page":"About","title":"About","text":"This section defines a few terms that are used across the package.  See the specific section of the documentation for a more thorough explanation.","category":"page"},{"location":"#","page":"About","title":"About","text":"Entity: An entity is a traffic participant that navigates in the environment, it is defined by a physical state (position, velocity, ...), an agent definition (whether it is a car or pedestrian, how large it is, ...), and an ID.\nScene: A scene represents a snapshot in time of a driving situation, it essentially consists of a list of entities at a given time.\nDriver Model: A driver model is a distribution over actions. Given a scene, each entity can update its model, we call this process observation (the corresponding method is observe!). After observing the scene, an action can be sampled from the driver model (using rand).\nActions: An action consists of a command applied to move the entity (e.g. longitudinal acceleration, steering). The state of the entity is updated using the propagate method which encodes the dynamics model.","category":"page"},{"location":"#","page":"About","title":"About","text":"This package provides a default structure for representing entity states, entities, scenes, driver models and actions. However it has been designed to support custom types.  Each section of the documentation contains an interface, which is a list of functions that a user must implement to use its own types.","category":"page"},{"location":"#","page":"About","title":"About","text":"","category":"page"}]
}
